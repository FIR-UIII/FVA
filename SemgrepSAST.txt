                                       
                                       
┌─────────────────────────────────────┐
│ 1 Undetermined Supply Chain Finding │
└─────────────────────────────────────┘
                    
    requirements.txt
    ❯❱ flask-cors - CVE-2024-6221
          Severity: MODERATE                                                        
          Affected versions of flask-cors are vulnerable to Improper Access Control.
                                                                                    
           ▶▶┆ Fixed for flask-cors at version: 
            8┆ Flask-Cors==4.0.1
                                 
                                 
┌───────────────────────────────┐
│ 44 Non-blocking Code Findings │
└───────────────────────────────┘
                      
    docker-compose.yml
    ❯❱ yaml.docker-compose.security.no-new-privileges.no-new-privileges
          Service 'db' allows for privilege escalation via setuid or setgid binaries. Add 'no-new-
          privileges:true' in 'security_opt' to prevent this.                                     
          Details: https://sg.run/0n8q                                                            
                                                                                                  
            4┆ db:
   
    ❯❱ yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service
          Service 'db' is running with a writable root filesystem. This may allow malicious applications to
          download and run additional payloads, or modify container files. If an application inside a      
          container has to save something temporarily consider using a tmpfs. Add 'read_only: true' to this
          service to prevent this.                                                                         
          Details: https://sg.run/e4JE                                                                     
                                                                                                           
            4┆ db:
           
    main.py
    ❯❱ python.django.security.injection.sql.sql-injection-using-db-cursor-execute.sql-injection-db-cursor-execute
          User-controlled data from a request is passed to 'execute()'. This could lead to a SQL injection and
          therefore protected information could be leaked. Instead, use django's QuerySets, which are built   
          with query parameterization and therefore not vulnerable to sql injection. For example, you could   
          use `Entry.objects.filter(date=2006)`.                                                              
          Details: https://sg.run/qx7y                                                                        
                                                                                                              
           59┆ username = request.form['username']
           60┆ password = request.form['password']
           61┆
           62┆ # Connect to the PostgreSQL database
           63┆ conn = psql.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASS, host=DB_HOST)
           64┆ cursor = conn.cursor()
           65┆
           66┆ query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
               #<-- vulnerable to SQL injection                                                        
           67┆ cursor.execute(query)
            ⋮┆----------------------------------------
           60┆ password = request.form['password']
           61┆
           62┆ # Connect to the PostgreSQL database
           63┆ conn = psql.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASS, host=DB_HOST)
           64┆ cursor = conn.cursor()
           65┆
           66┆ query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
               #<-- vulnerable to SQL injection                                                        
           67┆ cursor.execute(query)
   
   ❯❯❱ python.django.security.injection.tainted-sql-string.tainted-sql-string
          Detected user input used to manually construct a SQL string. This is usually bad practice because 
          manual construction could accidentally result in a SQL injection. An attacker could use a SQL     
          injection to steal or modify contents of the database. Instead, use a parameterized query which is
          available by default in most database engines. Alternatively, consider using the Django object-   
          relational mappers (ORM) instead of raw SQL queries.                                              
          Details: https://sg.run/PbZp                                                                      
                                                                                                            
           66┆ query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
               #<-- vulnerable to SQL injection                                                        
    
    
          Taint comes from:
    
           59┆ username = request.form['username']
    
    
          Taint flows through these intermediate variables:
    
           59┆ username = request.form['username']
    
    
                This is how taint reaches the sink:
    
           66┆ query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
               #<-- vulnerable to SQL injection                                                        
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ python.flask.security.injection.tainted-sql-string.tainted-sql-string
          Detected user input used to manually construct a SQL string. This is usually bad practice because 
          manual construction could accidentally result in a SQL injection. An attacker could use a SQL     
          injection to steal or modify contents of the database. Instead, use a parameterized query which is
          available by default in most database engines. Alternatively, consider using an object-relational 
          mapper (ORM) such as SQLAlchemy which will protect your queries.                                  
          Details: https://sg.run/JxZj                                                                      
                                                                                                            
           66┆ query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
               #<-- vulnerable to SQL injection                                                        
    
    
          Taint comes from:
    
           59┆ username = request.form['username']
    
    
          Taint flows through these intermediate variables:
    
           59┆ username = request.form['username']
    
    
                This is how taint reaches the sink:
    
           66┆ query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
               #<-- vulnerable to SQL injection                                                        
    
    
            ⋮┆----------------------------------------
   
    ❯❱ python.lang.security.audit.formatted-sql-query.formatted-sql-query
          Detected possible formatted SQL query. Use parameterized queries instead.
          Details: https://sg.run/EkWw                                             
                                                                                   
           67┆ cursor.execute(query)
   
    ❯❱ python.lang.security.audit.sqli.psycopg-sqli.psycopg-sqli
          Detected string concatenation with a non-literal variable in a psycopg2 Python SQL statement. This 
          could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order
          to prevent SQL injection, use parameterized queries or prepared statements instead. You can use    
          prepared statements by creating a 'sql.SQL' string. You can also use the pyformat binding style to 
          create parameterized queries. For example: 'cur.execute(SELECT * FROM table WHERE name=%s,         
          user_input)'                                                                                       
          Details: https://sg.run/qrLe                                                                       
                                                                                                             
           67┆ cursor.execute(query)
   
   ❯❯❱ python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query
          Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL
          Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy      
          provides TextualSQL to easily used prepared statement with named parameters. For complex SQL        
          composition, use SQL Expression Language or Schema Definition Language. In most cases, SQLAlchemy   
          ORM will be a better option.                                                                        
          Details: https://sg.run/2b1L                                                                        
                                                                                                              
           67┆ cursor.execute(query)
   
    ❯❱ python.flask.security.audit.secure-set-cookie.secure-set-cookie
          Found a Flask cookie with insecurely configured properties.  By default the secure, httponly and   
          samesite ar configured insecurely. cookies should be handled securely by setting `secure=True`,    
          `httponly=True`, and `samesite='Lax'` in response.set_cookie(...). If these parameters are not     
          properly set, your cookies are not properly protected and are at risk of being stolen by an        
          attacker. Include the `secure=True`, `httponly=True`, `samesite='Lax'` arguments or set these to be
          true in the Flask configuration.                                                                   
          Details: https://sg.run/gLkZ                                                                       
                                                                                                             
           76┆ resp.set_cookie('user_id', encoded_user_id)
   
     ❱ python.flask.web.flask-cookie-httponly-missing.flask-cookie-httponly-missing
          Detected a cookie where the `HttpOnly` flag is either missing or disabled. The `HttpOnly` cookie   
          flag instructs the browser to forbid client-side JavaScript to read the cookie. If JavaScript      
          interaction is required, you can ignore this finding. However, set the `HttpOnly` flag to `true` in
          all other cases. If this wasn't intentional, it's recommended to set the HttpOnly flag to true so  
          the cookie will not be accessible through client-side scripts. A secure default approach would     
          consist of creating a custom response class, overriding the `set_cookie` method to set this flag to
          `True` by default, setting the `response_class` attribute of your Flask app to use the custom      
          response class, setting the flag to False on a case-by-case basis only when necessary.             
          Details: https://sg.run/x8Z4j                                                                      
                                                                                                             
           ▶▶┆ Autofix ▶ resp.set_cookie('user_id', encoded_user_id, httponly=True)
           76┆ resp.set_cookie('user_id', encoded_user_id)
   
     ❱ python.flask.web.flask-cookie-samesite-missing.flask-cookie-samesite-missing
          Detected a cookie options with the `SameSite` flag set to "None". This is a potential security risk 
          that arises from the way web browsers manage cookies. In a typical web application, cookies are used
          to store and transmit session-related data between a client and a server. To enhance security,      
          cookies can be marked with the "SameSite" attribute, which restricts their usage based on the origin
          of the page that set them. This attribute can have three values: "Strict," "Lax," or "None". Make   
          sure that the choice of the `None` value is intentional and that you understand the potential       
          security implications. When `SameSite` is set to "Strict", no 3rd party cookie will be sent with    
          outgoing requests. While 'Strict' is the most secure option, 'Lax' is a good compromise between     
          security and usability and this default value is secure for most applications. A secure default     
          approach would consist of creating a custom response class, overriding the `set_cookie` method to   
          set this flag to `Lax` by default, setting the `response_class` attribute of your Flask app to use  
          the custom response class, setting the flag a different value on a case-by-case basis only when     
          necessary.                                                                                          
          Details: https://sg.run/Orzy7                                                                       
                                                                                                              
           ▶▶┆ Autofix ▶ resp.set_cookie('user_id', encoded_user_id, samesite='Lax')
           76┆ resp.set_cookie('user_id', encoded_user_id)
   
     ❱ python.flask.web.flask-cookie-secure-missing.flask-cookie-secure-missing
          Detected a cookie where the `Secure` flag is either missing or disabled. The `Secure` cookie flag 
          instructs the browser to forbid sending the cookie over an insecure HTTP request. Set the `Secure`
          flag to `true` so the cookie will only be sent over HTTPS. If this wasn't intentional, it's       
          recommended to set the Secure flag to true so the cookie will always be sent over HTTPS. A secure 
          default approach would consist of creating a custom response class, overriding the `set_cookie`   
          method to set this flag to `True` by default, setting the `response_class` attribute of your Flask
          app to use the custom response class, setting the flag to False on a case-by-case basis only when 
          necessary.                                                                                        
          Details: https://sg.run/d8O1n                                                                     
                                                                                                            
           ▶▶┆ Autofix ▶ resp.set_cookie('user_id', encoded_user_id, secure=True)
           76┆ resp.set_cookie('user_id', encoded_user_id)
   
     ❱ python.flask.debug.debug-flask.active-debug-code-flask
          The application is running debug code or has debug mode enabled. This may expose sensitive       
          information, like stack traces and environment variables, to attackers. It may also modify       
          application behavior, potentially enabling attackers to bypass restrictions. To remediate this   
          finding, ensure that the application's debug code and debug mode are disabled or removed from the
          production environment.                                                                          
          Details: https://sg.run/lBbpB                                                                    
                                                                                                           
          135┆ FVA.run(host="0.0.0.0", port=8888, debug=True)
   
    ❯❱ python.flask.security.audit.debug-enabled.debug-enabled
          Detected Flask app with debug=True. Do not deploy to production with this flag enabled as it will   
          leak sensitive information. Instead, consider using Flask configuration variables or setting 'debug'
          using system environment variables.                                                                 
          Details: https://sg.run/dKrd                                                                        
                                                                                                              
          135┆ FVA.run(host="0.0.0.0", port=8888, debug=True)
                   
    modules/BOLA.py
    ❯❱ python.lang.security.audit.sqli.psycopg-sqli.psycopg-sqli
          Detected string concatenation with a non-literal variable in a psycopg2 Python SQL statement. This 
          could lead to SQL injection if the variable is user-controlled and not properly sanitized. In order
          to prevent SQL injection, use parameterized queries or prepared statements instead. You can use    
          prepared statements by creating a 'sql.SQL' string. You can also use the pyformat binding style to 
          create parameterized queries. For example: 'cur.execute(SELECT * FROM table WHERE name=%s,         
          user_input)'                                                                                       
          Details: https://sg.run/qrLe                                                                       
                                                                                                             
           38┆ sql_command.execute("SELECT * FROM " + str(callDBName))
   
   ❯❯❱ python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query
          Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL
          Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy      
          provides TextualSQL to easily used prepared statement with named parameters. For complex SQL        
          composition, use SQL Expression Language or Schema Definition Language. In most cases, SQLAlchemy   
          ORM will be a better option.                                                                        
          Details: https://sg.run/2b1L                                                                        
                                                                                                              
           38┆ sql_command.execute("SELECT * FROM " + str(callDBName))
   
   ❯❯❱ python.django.security.injection.tainted-sql-string.tainted-sql-string
          Detected user input used to manually construct a SQL string. This is usually bad practice because 
          manual construction could accidentally result in a SQL injection. An attacker could use a SQL     
          injection to steal or modify contents of the database. Instead, use a parameterized query which is
          available by default in most database engines. Alternatively, consider using the Django object-   
          relational mappers (ORM) instead of raw SQL queries.                                              
          Details: https://sg.run/PbZp                                                                      
                                                                                                            
           38┆ sql_command.execute("SELECT * FROM " + str(callDBName))
    
    
          Taint comes from:
    
           51┆ data = request.get_json()
    
    
          Taint flows through these intermediate variables:
    
           51┆ data = request.get_json()
    
           52┆ parameter_received = data.get('param', None)
    
    
                This is how taint reaches the sink:
    
           53┆ resultParam = str(database_worker(parameter_received[0]))
    
          Taint flows through these intermediate variables:
    
           34┆ def database_worker(callDBName):
    
          then reaches:
    
           38┆ sql_command.execute("SELECT * FROM " + str(callDBName))
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ python.flask.security.injection.tainted-sql-string.tainted-sql-string
          Detected user input used to manually construct a SQL string. This is usually bad practice because 
          manual construction could accidentally result in a SQL injection. An attacker could use a SQL     
          injection to steal or modify contents of the database. Instead, use a parameterized query which is
          available by default in most database engines. Alternatively, consider using an object-relational 
          mapper (ORM) such as SQLAlchemy which will protect your queries.                                  
          Details: https://sg.run/JxZj                                                                      
                                                                                                            
           38┆ sql_command.execute("SELECT * FROM " + str(callDBName))
    
    
          Taint comes from:
    
           51┆ data = request.get_json()
    
    
          Taint flows through these intermediate variables:
    
           51┆ data = request.get_json()
    
           52┆ parameter_received = data.get('param', None)
    
    
                This is how taint reaches the sink:
    
           53┆ resultParam = str(database_worker(parameter_received[0]))
    
          Taint flows through these intermediate variables:
    
           34┆ def database_worker(callDBName):
    
          then reaches:
    
           38┆ sql_command.execute("SELECT * FROM " + str(callDBName))
    
                   
    modules/IDOR.py
    ❯❱ python.flask.security.audit.render-template-string.render-template-string
          Found a template created with string formatting. This is susceptible to server-side template
          injection and cross-site scripting attacks.                                                 
          Details: https://sg.run/8yjE                                                                
                                                                                                      
           32┆ return render_template_string(html_content)
            ⋮┆----------------------------------------
           70┆ return render_template_string(html_content)
            ⋮┆----------------------------------------
          110┆ return render_template_string(html_content)
                   
    modules/chat.py
   ❯❯❱ javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket
          Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.
          Details: https://sg.run/GWyz                                                                     
                                                                                                           
           30┆ const socket = new WebSocket('ws://' + location.host + '/echo');
   
     ❱ python.flask.debug.debug-flask.active-debug-code-flask
          The application is running debug code or has debug mode enabled. This may expose sensitive       
          information, like stack traces and environment variables, to attackers. It may also modify       
          application behavior, potentially enabling attackers to bypass restrictions. To remediate this   
          finding, ensure that the application's debug code and debug mode are disabled or removed from the
          production environment.                                                                          
          Details: https://sg.run/lBbpB                                                                    
                                                                                                           
           56┆ app.run(debug=True)
   
    ❯❱ python.flask.security.audit.debug-enabled.debug-enabled
          Detected Flask app with debug=True. Do not deploy to production with this flag enabled as it will   
          leak sensitive information. Instead, consider using Flask configuration variables or setting 'debug'
          using system environment variables.                                                                 
          Details: https://sg.run/dKrd                                                                        
                                                                                                              
           56┆ app.run(debug=True)
                                
    modules/command_injection.py
   ❯❯❱ python.flask.security.injection.subprocess-injection.subprocess-injection
          Detected user input entering a `subprocess` call unsafely. This could result in a command injection 
          vulnerability. An attacker could use this vulnerability to execute arbitrary commands on the host,  
          which allows them to download malware, scan sensitive data, or run any command they wish on the     
          server. Do not let users choose the command to run. In general, prefer to use Python API versions of
          system commands. If you must use subprocess, use a dictionary to allowlist a set of commands.       
          Details: https://sg.run/5gW3                                                                        
                                                                                                              
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
    
    
          Taint comes from:
    
           14┆ command = request.form.get('command') # => no user validation
    
    
          Taint flows through these intermediate variables:
    
           14┆ command = request.form.get('command') # => no user validation
    
    
                This is how taint reaches the sink:
    
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ python.flask.os.tainted-os-command-stdlib-flask-secure-default.tainted-os-command-stdlib-flask-secure-default
          Untrusted input might be injected into a command executed by the application, which can lead to a   
          command injection vulnerability. An attacker can execute arbitrary commands, potentially gaining    
          complete control of the system. To prevent this vulnerability, avoid executing OS commands with user
          input. If this is unavoidable, validate and sanitize the input, and use safe methods for executing  
          the commands. Untrusted input in a command can lead to command injection, allowing attackers to     
          execute arbitrary commands and gain control of the system. To prevent this: 1. Avoid direct command 
          execution: Don't run OS commands with user input directly. 2. Validate and sanitize input: Ensure   
          input is safe by removing or escaping dangerous characters. 3. (preferred) Use safe methods: Use    
          `subprocess.run` without `shell=True` to safely execute commands, as it doesn't call a system shell 
          by default. If `shell=True` is necessary, properly quote and escape all input to prevent shell      
          injection. This is a secure by default approach.                                                    
          Details: https://sg.run/bwGOd                                                                       
                                                                                                              
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
    
    
          Taint comes from:
    
           14┆ command = request.form.get('command') # => no user validation
    
    
          Taint flows through these intermediate variables:
    
           14┆ command = request.form.get('command') # => no user validation
    
    
                This is how taint reaches the sink:
    
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ python.lang.security.dangerous-subprocess-use.dangerous-subprocess-use
          Detected subprocess function 'check_output' with user controlled data. A malicious actor could
          leverage this to perform command injection. You may consider using 'shlex.escape()'.          
          Details: https://sg.run/NWxp                                                                  
                                                                                                        
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
    
    
          Taint comes from:
    
           14┆ command = request.form.get('command') # => no user validation
    
    
          Taint flows through these intermediate variables:
    
           14┆ command = request.form.get('command') # => no user validation
    
    
                This is how taint reaches the sink:
    
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ python.lang.security.audit.subprocess-shell-true.subprocess-shell-true
          Found 'subprocess' function 'check_output' with 'shell=True'. This is dangerous because this call 
          will spawn the command using a shell process. Doing so propagates current shell settings and      
          variables, which makes it much easier for a malicious actor to execute commands. Use 'shell=False'
          instead.                                                                                          
          Details: https://sg.run/J92w                                                                      
                                                                                                            
           ▶▶┆ Autofix ▶ False
           17┆ result = subprocess.check_output(command, shell=True, text=True) # => command injection
               withoit validation and restriction                                                     
                   
    modules/csrf.py
    ❯❱ python.flask.security.audit.directly-returned-format-string.directly-returned-format-string
          Detected Flask route directly returning a formatted string. This is subject to cross-site scripting
          if user input can reach the string. Consider using the template engine instead and rendering pages 
          with 'render_template()'.                                                                          
          Details: https://sg.run/Zv6o                                                                       
                                                                                                             
           23┆ return f"Password for user '{passwords[id-1]['username']}' has been successfully changed to
               '{new_password}'. + {passwords}"                                                           
    
    
          Taint comes from:
    
           41┆ id = int(request.form.get('id'))
    
    
          Taint flows through these intermediate variables:
    
           41┆ id = int(request.form.get('id'))
    
    
                This is how taint reaches the sink:
    
           44┆ return password_changer(id, new_password)
    
          Taint flows through these intermediate variables:
    
           19┆ def password_changer(id, new_password):
    
          then reaches:
    
           23┆ return f"Password for user '{passwords[id-1]['username']}' has been successfully changed to
               '{new_password}'. + {passwords}"                                                           
    
    
            ⋮┆----------------------------------------
           26┆ return f"Password for user '{passwords[id-1]['username']}' has been successfully changed to
               '{new_password}'. + {passwords}"                                                           
    
    
          Taint comes from:
    
           41┆ id = int(request.form.get('id'))
    
    
          Taint flows through these intermediate variables:
    
           41┆ id = int(request.form.get('id'))
    
    
                This is how taint reaches the sink:
    
           44┆ return password_changer(id, new_password)
    
          Taint flows through these intermediate variables:
    
           19┆ def password_changer(id, new_password):
    
          then reaches:
    
           26┆ return f"Password for user '{passwords[id-1]['username']}' has been successfully changed to
               '{new_password}'. + {passwords}"                                                           
    
                   
    modules/ssrf.py
   ❯❯❱ python.flask.net.tainted-flask-http-request-requests.tainted-flask-http-request-requests
          Untrusted input might be used to build an HTTP request, which can lead to a Server-side request    
          forgery (SSRF) vulnerability. SSRF allows an attacker to send crafted requests from the server side
          to other internal or external systems. SSRF can lead to unauthorized access to sensitive data and, 
          in some cases, allow the attacker to control applications or systems that trust the vulnerable     
          service. To prevent this vulnerability, avoid allowing user input to craft the base request.       
          Instead, treat it as part of the path or query parameter and encode it appropriately. When user    
          input is necessary to prepare the HTTP request, perform strict input validation. Additionally,     
          whenever possible, use allowlists to only interact with expected, trusted domains.                 
          Details: https://sg.run/109zk                                                                      
                                                                                                             
           20┆ response = requests.get(url)
    
    
          Taint comes from:
    
           12┆ url = request.args.get('url') #<--user input without proper validation
    
    
          Taint flows through these intermediate variables:
    
           12┆ url = request.args.get('url') #<--user input without proper validation
    
    
                This is how taint reaches the sink:
    
           20┆ response = requests.get(url)
    
                   
    modules/ssti.py
    ❯❱ python.django.security.injection.raw-html-format.raw-html-format
          Detected user input flowing into a manually constructed HTML string. You may be accidentally       
          bypassing secure methods of rendering HTML by manually constructing HTML and this could create a   
          cross-site scripting vulnerability, which could let attackers steal sensitive user data. To be sure
          this is safe, check that the HTML is rendered safely. Otherwise, use templates                     
          (`django.shortcuts.render`) which will safely render HTML instead.                                 
          Details: https://sg.run/oYj1                                                                       
                                                                                                             
           12┆     template = '''<!DOCTYPE html>
           13┆ <html>
           14┆ <head>
           15┆     <title>SSTI</title>
           16┆     <link rel="stylesheet" href="static/bootstrap.min.css">
           17┆     <link rel="icon" href="static/scripting.png" type="image/x-icon">
           18┆ </head>
           19┆ <body>
           20┆     <div class="container mt-5">
           21┆             <pre class="alert alert-info"><b>Пользовательский ввод:
               </b>'''+user_input+'''</pre>                                       
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
    
    
          Taint comes from:
    
           11┆ user_input = request.args.get('param', 'Введите данные в query "?param="') #<-- точка ввода
               через query параметры xss reflected + SSTI                                                 
    
    
          Taint flows through these intermediate variables:
    
           11┆ user_input = request.args.get('param', 'Введите данные в query "?param="') #<-- точка ввода
               через query параметры xss reflected + SSTI                                                 
    
    
                This is how taint reaches the sink:
    
           12┆     template = '''<!DOCTYPE html>
    
           13┆ <html>
    
           14┆ <head>
    
           15┆     <title>SSTI</title>
    
           16┆     <link rel="stylesheet" href="static/bootstrap.min.css">
    
           17┆     <link rel="icon" href="static/scripting.png" type="image/x-icon">
    
           18┆ </head>
    
           19┆ <body>
    
           20┆     <div class="container mt-5">
    
           21┆             <pre class="alert alert-info"><b>Пользовательский ввод:
               </b>'''+user_input+'''</pre>                                       
    
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
    
    
            ⋮┆----------------------------------------
   
    ❯❱ python.flask.security.injection.raw-html-concat.raw-html-format
          Detected user input flowing into a manually constructed HTML string. You may be accidentally       
          bypassing secure methods of rendering HTML by manually constructing HTML and this could create a   
          cross-site scripting vulnerability, which could let attackers steal sensitive user data. To be sure
          this is safe, check that the HTML is rendered safely. Otherwise, use templates                     
          (`flask.render_template`) which will safely render HTML instead.                                   
          Details: https://sg.run/Pb7e                                                                       
                                                                                                             
           12┆     template = '''<!DOCTYPE html>
           13┆ <html>
           14┆ <head>
           15┆     <title>SSTI</title>
           16┆     <link rel="stylesheet" href="static/bootstrap.min.css">
           17┆     <link rel="icon" href="static/scripting.png" type="image/x-icon">
           18┆ </head>
           19┆ <body>
           20┆     <div class="container mt-5">
           21┆             <pre class="alert alert-info"><b>Пользовательский ввод:
               </b>'''+user_input+'''</pre>                                       
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
    
    
          Taint comes from:
    
           11┆ user_input = request.args.get('param', 'Введите данные в query "?param="') #<-- точка ввода
               через query параметры xss reflected + SSTI                                                 
    
    
          Taint flows through these intermediate variables:
    
           11┆ user_input = request.args.get('param', 'Введите данные в query "?param="') #<-- точка ввода
               через query параметры xss reflected + SSTI                                                 
    
    
                This is how taint reaches the sink:
    
           12┆     template = '''<!DOCTYPE html>
    
           13┆ <html>
    
           14┆ <head>
    
           15┆     <title>SSTI</title>
    
           16┆     <link rel="stylesheet" href="static/bootstrap.min.css">
    
           17┆     <link rel="icon" href="static/scripting.png" type="image/x-icon">
    
           18┆ </head>
    
           19┆ <body>
    
           20┆     <div class="container mt-5">
    
           21┆             <pre class="alert alert-info"><b>Пользовательский ввод:
               </b>'''+user_input+'''</pre>                                       
    
             [hid 4 additional lines, adjust with --max-lines-per-finding] 
    
    
            ⋮┆----------------------------------------
   
    ❯❱ python.flask.security.audit.render-template-string.render-template-string
          Found a template created with string formatting. This is susceptible to server-side template
          injection and cross-site scripting attacks.                                                 
          Details: https://sg.run/8yjE                                                                
                                                                                                      
           27┆ return render_template_string(template) #<-- небезопасный вывод пользователю данных без
               санитизации                                                                            
                            
    payload/hacker_csrf.html
    ❯❱ python.django.security.django-no-csrf-token.django-no-csrf-token
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
            9┆ <form hidden id="hack" target="csrf-frame" action="http://localhost:8888/change_password"
               method="POST" autocomplete="off">                                                        
           10┆     <input type="text" id="id" name="id" value="1">
           11┆     <input type="text" id="new_password" name="new_password" value="h@cked_by_'"><br>
           12┆ </form>
                          
    static/scripts/bola.js
   ❯❯❱ typescript.react.security.react-insecure-request.react-insecure-request
          Unencrypted request over HTTP detected.
          Details: https://sg.run/1n0b           
                                                 
            3┆ fetch('http://localhost:8888/idor/bola', {
            4┆     // Specify that the request method is POST
            5┆     method: 'POST', headers: {
            6┆         'Content-Type': 'application/json'
            7┆     }, body: JSON.stringify({ param: parameterToSend })
            8┆ }).then(response => response.json())
                       
    templates/chat.html
   ❯❯❱ javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket
          Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.
          Details: https://sg.run/GWyz                                                                     
                                                                                                           
           19┆ const socket = new WebSocket('ws://' + location.host + '/echo');
                                    
    templates/command_injection.html
    ❯❱ python.django.security.django-no-csrf-token.django-no-csrf-token
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
           10┆ <form action="/execute" method="post">
           11┆     <label for="command">Введите команду:</label><br>
           12┆     <input type="text" id="command" name="command"><br>
           13┆     <input type="submit" value="Go"></p>
           14┆ </form>
                       
    templates/csrf.html
    ❯❱ python.django.security.django-no-csrf-token.django-no-csrf-token
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
           10┆ <form action="/change_password" method="post" id="changePasswordForm">
           11┆     <label for="id">Введите id пользователя:</label><br>
           12┆     <input type="text" id="id" name="id"><br>
           13┆     <label for="command">Введите новый пароль:</label><br>
           14┆     <input type="text" id="new_password" name="new_password"><br>
           15┆     <input type="submit" value="Изменить пароль"></p>
           16┆ </form>
                        
    templates/login.html
    ❯❱ python.django.security.django-no-csrf-token.django-no-csrf-token
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
           12┆ <form action="/" method="post">
           13┆     <label for="username">Username:</label>
           14┆     <input type="text" id="username" name="username" required>
           15┆     <br>
           16┆     <label for="password">Password:</label>
           17┆     <input type="password" id="password" name="password" required>
           18┆     <br><br>
           19┆     <button type="submit" class="btn btn-primary">Войти</button>
           20┆     <br>
           21┆ </form>
                         
    templates/upload.html
    ❯❱ python.django.security.django-no-csrf-token.django-no-csrf-token
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
           10┆ <form action="/api/data" method="post" enctype="multipart/form-data">
           11┆   <input type="file" name="file">
           12┆   <input type="submit" value="Upload">
           13┆ </form>
                      
    templates/xss.html
    ❯❱ python.django.security.django-no-csrf-token.django-no-csrf-token
          Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.
          Details: https://sg.run/N0Bp                                                                   
                                                                                                         
           10┆ <form method="POST">
           11┆     <input type="text" name="user_input" placeholder="Напиши сюда >..<"></p>
           12┆     <input class="btn btn-primary" type="submit"></p>
           13┆ </form>
   
    ❯❱ python.flask.security.xss.audit.template-autoescape-off.template-autoescape-off
          Detected a segment of a Flask template where autoescaping is explicitly disabled with '{% autoescape
          off %}'. This allows rendering of raw HTML in this segment. Ensure no user data is rendered here,   
          otherwise this is a cross-site scripting (XSS) vulnerability, or turn autoescape on.                
          Details: https://sg.run/Bkn2                                                                        
                                                                                                              
           14┆ {% autoescape false %}
